第一.单一职责原则(SRP)：一个类只有一个引起它变化的原因。
	如果一个类承担职责过多，就等于把这些职责耦合在一起，一个职责变化可能会消弱或者影响这个类完成其他职责的能力。
	软件设计的真正要做的许多内容，就是发现职责并把那些职责相互分离；如果能够想到多于一个动机去改变一个类，那么这个类就具有多于一个职责，就应该考虑类的职责分离。
	
第二.开放-封闭原则(OCP)：软件实体（类、模块、函数/方法等等）应该可以扩展，但是不可修改。
	绝对的对修改封闭式不可能的。模块都会纯在一些无法对之封闭的变化。设计人员必须对于他设计的模块应该对于哪一种变化封闭做出选择。必须先猜测出最有可能的发生的变化种类，然后接着抽象来隔离那些变化。
	面对需求，对程序的改动是通过新增代码进行的，而不是更改现有代码。
	开放-封闭原则是面向对象设计的核心所在。开发人员应该对程序中呈现出频繁变化的那些部分作出抽象。然而，对于应用程序中每个部分都刻意的进行抽象同样不是好主意。拒绝不成熟的抽象和抽象本身一样重要。
	
第三.里氏代换原则：子类必须能够替换掉它们的父类型。
	在软件中，把父类都替换成它的子类，程序的行为没有变化。
	只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也才能够在父类的基础上增加新的行为。
	由于子类型的可替代性才使得使用父类型的模块在无需修改的情况下就能够扩展。

第四.依赖倒置原则。
	A．高层模块不应该依赖低层模块。二者都应该依赖抽象。
	B． 抽象不应该依赖细节。细节应该依赖抽象。
	面向过程开发时，为了使得常用代码可以复用，一般都会把这些代码常用代码写成许多函数的程序库，这样在做新项目时，去调用这些低层的函数就可以了。这就叫做高层模块依赖低层模块。依赖倒转原则就是不管高层模块还是低层模块，都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易被复用。
	如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计。
	
第五.迪米特法则（最少知识原则）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
	迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。其根本思想是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。
	
第六.合成/聚合复用原则：尽量使用合成和聚合，尽量不要使用类继承。
	聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。

	优先使用对象的合成/聚合将有助于保持每个类的封装，并被集中在单个任务上。这样类和类继承层次会保持较小的规模，并且不太可能增长到不可控制的庞然大物。

================系统设计
系统可扩展性：整个系统设计应从"单一职责"概念进行考虑，尽量划分子系统。以备将来需求变化改动不影响其他功能。


================2012/7/30 看代码心得
今天看了一个不错的设计方案，
在代码设计编写中尽量降低代码的耦合性，像这样的方向考虑，
1.	定义抽象类，抽象出共有特性和共有方法。
2.	定义接口，控制向外部公开的属性和方法。
	a)	对多个对象需要向外部公开一些共有的属性使用。
3.	对函数的定义、对象的定义 与 函数的调用、对象的调用分开。
	a)	明确函数定义者(类)和函数调用者(类)。
	b)	函数定义者(类)，a.明确函数需要公开的属性和方法。b.多个类中是否能够抽象出共有的方法，并放入抽象类中。
	c)	函数调用者(类)，分不同情况调用函数定义者(类)中的方法。	
==================UML 用例 心得
1.一个完整的UML建立在完善的用户需求。
2.开始一个UML用例步骤
	a).明确一个具体场景。
	b).明确一个start
	c).一个执行过程
	d).一个明确的end
3. UML 建模方法包含：业务角色、业务实体、业务活动和业务流程等建模元素。以及业务实体关系图、业务流程活动那个图和业务状态等。
----------------UML建模迭代过程
	1. 概念层类图--应用领域的概念，这一步不考虑实现问题。
	2. 说明层类图--考虑接口部分，同样不考虑实现问题。
	3. 实现层类图--考虑类的实现问题，提供实现细节。
---------------UML 终结a
	分析阶段--主要识别问题域相关类。
	设计阶段--加入一些反映设计思想、方法的类以及实现问题域需要的类。
--------------建立UML类图的步骤
	1. 研究问题域确定系统需求。
	2. 确定类，明确类的含义、属性、职责
	3. 类之间关系。
-------------实现类图UML注意：
不要为每一个事物都画一个模型，把精力放在关键的领域。使用类图最大危险是过早的陷入实现的细节，为避免这个问题，应该将重点放在概念层和说明层。




====================DDD 领域驱动设计 
DDD :领域驱动设计    （领域对象统管封装行为和状态）（领域对象分割职责归属）
1. 将系统分成：controller > 粗粒度service > context > repository > dao
2. 实施DDD，CQRS读写分离是必须的架构--->事件驱动 
-------------bo->(business object)业务对象
对数据进行检索和处理的组件，是简单的真实世界的软件抽闲。
业务对象必要条件：1. 由状态和行为组成。
				  2. 表达了来自业务域的一个人，地点，事务或概念
				  3.可以重用
业务对象分类：
			1. 实体业务对象： 根据业务中的名词从业务域中提取。如客户，订单，物品。表达了一个人，地点，事物或者概念。
			2. 过程业务对象： 表达应用程序中业务处理过程或者工作流程任务。通常依赖于实体业务对象，是业务的动词。作为应用程序的管理者或者控制者。
			3. 时间业务对象： 表达应用程序中由于系统的一些操作造成或产生的一些事件。
------------vo->(value object)值对象
------------po->(presistant object)持久对象 ：可以看成是与数据库中的表相映射的对象
DDD问题：

	1. ddd 最大好处提炼bo和相关的行为，使系统代码设计不是以前台命令驱动，而是还原领域中的各种概念。
		问题：对OO抽象不到位，导致修改bo，与之关联的很多代码都需要修改。
	2. bo 必须缓存，bo创建代价很大，他有很多关联对象需要查询。
	3. 协作开发，职责划分。
	
目前解耦合：最普通面向接口，实际上接口耦合，最解耦合方式：消息或事件机制，消息或事件的生产者和使用者之间和消息或时间中间件耦合。
DDD 最有用的地方是以bo来描述业务。描述业务的地方明确，其他的层就可以复用。
=========别人的学习成果。
1. 创建领域对象采用构造函数或者工厂。
2. 一个聚合由一些相关的Entity和Value Object组成，一个聚合有一个聚合根，聚合根是Entity，整个聚合被看成是一个数据修改的单元，也就是说整个聚合内的所有对象要么同时被保存，要么都不能保存，即保存到数据持久层时必须以覆盖的方式来保存，。因为一个聚合是一个数据持久化的单元
   目前的内存缓存框架都已发展的比较成熟，性能已经不是问题；如MongoDb，MemCache，NoSQL，等等；

=========TCP及时通信程序设计
1. 主要采用服务器与客户端分离开发。涉及到服务器端和客户端的职责功能划分。可以根据职责设计接口。
	1.1. 服务器端：存放所有的用户client,接收用户发送的信息、转发至相应的用户，保存所有的OnlineUser，移除掉线的user，显示消息
	1.2. 客户端：查看出自己以外所有在线用户，添加用户，移除用户，对选中人员发送消息，接收消息，显示消息。
   
=====================
	需求分析方法
=====================
	1.功能分解法：将一个系统看成有若干功能结构组成。由功能、子功能、功能接口组成。-->问题(用户的功能需求不断的变化，功能分解法是基于功能一个不稳定的基点，难以适应需求的变化。)
	2.结构化分析法：问题空间到某种表示的映射方法。由数据流图和数据字典组成。-->结构化方法基本指导思想自顶向下，逐步求精，基本原则抽象和分解。 面向数据流的需求分析方法。
		2.1 数据流图DFD，描述系统是由哪几部分组成，各部分间有什么联系。
		2.2 数据字典DD，定义数据流图的数据和加工。
		2.3 描述加工逻辑的结构化语言、判定树、判定表。数据流图中不能被再分解的每一个基本加工的处理逻辑。
		-----实施结构化分析步骤：
		2.1 建立当前系统的物理模型,<可通过系统流程图反映系统的实际情况>  系统‘怎么做’的具体体现。
		2.2 抽象出当钱系统的逻辑模型，抽取出系统本质因素<系统本质因素，系统固有的、不依赖运行环境变化而变化的因素,任何实现都这样做>  系统‘做什么’的功能。
		2.3 建立目标系统的逻辑模型，比较目标系统与当前系统逻辑上的差别。
		2.4 作进一步补充和优化，以上不涉及系统细节。
	3.信息建模法：从数据角度对现实世界进行建模，E-R图，由实体、属性和联系3个基本要素构成。
	4.面向对象分析法：
	-----需求分析，强调需求的一致性、完整性、有效性和实现性。
	
	
====================
	交互设计
====================
	1.认知摩擦：人类与系统之间交互时会遇到障碍，如理解困难或理解不一致。-->良好的交互设计是消除或减小认知摩擦，使用户易学易用的设计。
	交互设计方法：
	目标导向设计方法(包括：角色设计、目标设计、任务设计、人性化设计设计阶段和手法。)
	1.角色设计。精确描述用户期望达到的目标。<构件用户角>
		1.1. 赋予角色严格而精确的定义。角色设计只为一类人设计。角色应该与真正的人区分开来。只有精确定义角色才能看出系统的实质，同时剔除不必要的功能。
		1.2. 角色设计只为中心服务，而不是为了边缘。
		1.3. 必须实际了解角色的技术水平。
		1.4. 设计师和程序员都需要角色。
	2.目标设计。


   

==============================================
				模块设计
==============================================
   模块结构图中的模块类型：
	1.传入模块：从下属模块中取得数据，经过处理传入上级模块。
	2.传出模块：从上级模块取得数据，经过处理传入到下级模块。
	3.变换模块：上级模块中取得数据加工之后插入上级模块。
	4.协调模块：对所有下属模块进行协调和管理的模块。应该在较高层出现，较好。
   
   
   
==============================================
				敏捷设计
==============================================
设计臭味：软件像一片坏面包一样开始腐化。随着事件的流失，腐化蔓延、增长。
腐化软件的气味：
僵化性：难以对软件进行改动，即使简单的改动。如果单一的改动会导致有依赖关系的模块中的连锁改动，那么设计就是僵化的。
脆弱性：软件在改动时，可能会导致程序的许多地方出现问题。常常是，出现新问题的地方与改动的地方并没有概念上的关联。
顽固性：设计中包含了对其他系统有用的部分，但要把这些部分从系统中分离出来需要的努力和风险非常巨大。
粘滞性：
不必要的复杂设计：设计中包含了当前没有用的组成部分，他就含有不比较的复杂性。
不必要的重复：当同样的代码以稍有不同的形式一再出现时，就表示开发人员忽视了抽象。
晦涩性：代码可以用清晰、富有表达力方式编写，也可以用晦涩、费解的方式编写。代码随着时间演化，往往会变得越来越晦涩。需要持续的重构保持代码清晰和富有表达力。

--------SRP 单一职责原则
	一个类应该只有一个发生变化的原因。一个类承担的职责过多，就等于把这些职责耦合在了一起。
	使用单一职责考虑类的职责： 如果能够想到多余一个动机去改变一个类，那没这个类就具有多余一个职责。
	如果接口的职责多余两个，把这个接口拆分为两个单一职责的接口。

--------OCP 开放-封闭原则
	软件实体，可以扩展的，但是不可修改。
	如果程序中的一处改动会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。
	具体做法：把共同的方法抽象到一个接口(或抽象类)中，当要增加新的类型只用在接口(或抽象类)上扩展其他的方法。
	OCP：抽象接口和抽象类。扩展派生类，保持原有类不变。
	正确的做法：开发人员应该仅仅对程序中呈现出频繁变化的那些部分做抽象。拒绝不成熟的抽象。

-------LSP Liskov替换原则
	任何基类可以出现的地方，子类一定可以出现。
	应为语言支持继承。
	一个函数f(D d) E继承了D  那么f(E e) 这样一定也可以通过。
	基于契约设计。

-------DIP 依赖倒置原则


-------接口隔离原则



--------有限状态机FSM
	定义：表示有限哥状态以及在这些状态之间的转移和动作等行为的数学模型。
	反映由进入系统到现在的输入变化。表述又一个状态迁徙到另一个状态和引起迁徙的事件。
	每一个状态机包含：
		进入动作：在进入状态机时产生
		退出动作: 退出状态机时进行
		输入动作：依赖当前状态和输入条件
		转移动作：进行特定转移时进行
		
---------实用类图：
	1. 在使用类图时，非常重要的一点要能够想象出代码。
	
--------什么情况使用接口
	1. 为什么使用接口，接口是用于定义类与类之间的交互的一个契约。 如果定义一个接口或抽象类他们没有被其他类或方法使用，存在的接口或抽象类就没有多大的意义了。
































	